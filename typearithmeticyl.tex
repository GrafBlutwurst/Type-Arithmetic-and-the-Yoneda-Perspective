% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]
\documentclass[tikz]{beamer}


\usepackage{minted}
\usepackage[parfill]{parskip}    		
\usepackage{graphicx}				
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{tikz-cd}
\usepackage{enumerate}
\usepackage{xfrac}
\usepackage{hyperref}
\usepackage{graphicx} \graphicspath{ {./} }
\usepackage{xcolor}


\newcommand{\cat}[1]{\bm{ \mathsf{#1} }}
\newcommand{\functor}[3]{#1 : \cat{#2} \to \cat{#3}}
\newcommand{\functordef}{\functor{F}{C}{D}}
\newcommand{\cc}{\cat{C}}
\newcommand{\dd}{\cat{D}}
\newcommand{\ee}{\cat{E}}
\newcommand{\subcat}[2]{\bm{ \mathsf{#1}}_{\bm{ \mathsf{#2}}}}
\newcommand{\op}[1]{#1^{\text{op}}}
\newcommand{\opc}{\op{\cc}}
\newcommand{\opd}{\op{\dd}}
\newcommand{\ope}{\op{\ee}}
\newcommand{\mono}{\rightarrowtail}
\newcommand{\epi}{\twoheadrightarrow}
\newcommand{\one}{\mathbb{1}}
\newcommand{\bg}{\cat{BG}}
\newcommand{\bgg}{\cat{BG'}}
\newcommand{\nt}{\Rightarrow}
\newcommand{\ant}[2]{\alpha : F \nt G} 
\newcommand{\bnt}[2]{\beta : F \nt G} 
\newcommand{\anti}[2]{\alpha : F \cong G} 
\newcommand{\bnti}[2]{\beta : F \cong G} 
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\mred}[1]{\textcolor{red}{$#1$}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\mblue}[1]{\textcolor{blue}{$#1$}}

\setbeamertemplate{navigation symbols}{\insertframenumber{}}
\colorlet{shadecolor}{gray!15}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\newcommand{\propnumber}{} % initialize
\newtheorem*{prop}{Proposition \propnumber}
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}


\title{Type Arithmetic and the Yoneda Lemma}
\author{Emily Pillmore}

\begin{document}

\frame{\titlepage}

\section[Outline]{}
\frame{\tableofcontents[hideallsubsections]}

\section{Introduction}
\subsection{Who am I?}

\frame
{
	My name is Emily Pillmore.
	
	I am a hopeful mathematician, and a moonlight programmer.
}

\frame
{
	\begin{itemize}
		\item Twitter (\href{https://twitter.com/emi1ypi}{@emi1ypi})
		\item Meetups in NYC: NY Homotopy Type Theory, NY Category Theory, and the NY Haskell User Group. 
		\item Discord: Haskell $\cap$ Dank Memes: \href{https://discord.gg/2x2fYSK}{https://discord.gg/2x2fYSK}. 
		\item Personal: All of my slides and meetup content are hosted at \href{https://github.com/cohomolo-gy}{cohomolo.gy}.
	\end{itemize}
	
}

\frame
{
	I got my start in Scala, with Runar's \textit{Functional Programming in Scala} (the \textcolor{red}{red one} - there is now a \textcolor{blue}{blue one})
}


\frame
{ 
	I now work at a company called \textbf{Kadena}, designing a language and a couple of cool blockchains
	\begin{center}
	
		\includegraphics[scale=0.3]{kadena}
	\end{center}
	
}

\subsection{Why are we here?}

\frame
{ 
	Today, we're going to learn to \textbf{count}. Then we will learn to \textbf{add}, \textbf{multiple}, and even \textbf{take powers}. 
}

\frame
{ 
	...and we will do this with the language of Type Theory, Category Theory, and Constructive Logic. Hopefully you will be converted to Computational Trinitarianism by the time we're done.
}

\frame
{ 
	Many of you know these topics already without knowing the details. Much of it is folklore within the community. But there are new ways of thinking about it that I gaurantee you haven't seen before, and some of it even translates into our work on Profunctor Optics! 
}

\frame
{ 
	If Bartosz is in this audience, everyone stare at him right now. 
}

\frame
{ 
	We'll see if we have time for that last one. If we don't get to it, it will be included as an optional set of slides. 
}

\subsection{What and How?}

\frame
{ 
	First, we'll start off with some exercises to illustrate the point, proving free theorems and basic facts about types (e.g. reasoning through why \red{$\forall a. a \to a$} has precisely 1 inhabitant), and then draw direct lines with the Lambek correspondence. 
}

\frame
{ 
	Second, we will try to understand the Leibniz perspective and how it informs the Curry-Howard correspondence. 
}

\frame
{ 
	Third, we will begin to build the requisite knowledge for understanding the Yoneda perspective, and build some categorical constructs, and an understanding of representation. 
}

\frame
{ 
	Then, we will tie it all together. 
}

\frame
{ 
	Special thanks to Jon Pretty (\href{https://twitter.com/propensive}{@propensive})
}

\section{Some Type Arithmetic}

\frame
{
	Let's do a quick warm up 
}

\subsection{Ground Rules}

\frame
{ 
	We will use the following conventions: 
	
	\begin{itemize}
		\item the type \red{()} with precisely 1 inhabitant (called \blue{Unit}) will be denoted by the number \red{1}. 
		\item the type with no inhabitants, \blue{Nothing} or \red{undefined} will be denoted \red{0}. 
		\item Function types will be denoted by \red{$a \to b$} or by the notation \red{$b^a$}. 
		\item Universal quantification is given by \red{forall} or \red{$\forall$}.
	\end{itemize}
}

\frame
{
	\begin{itemize}
		\item Our calculus assumes that we have all finite coproducts and will denote them by the plus sign \red{+}. In Scala and Haskell, the binary coproduct is \red{Either}.
		\item Our calculus assumes that we have all finite products, and we will denote they by the times sign \red{*}. In Scala and Haskell, the binary product is \red{(,)} or (\red{(,)} is an alias for \blue{Tuple2} in Scala.
	\end{itemize}
}

\frame
{ 
	Proposition: Suppose we were to treat a polymorphic type like your standard high school arithmetic. What would this arithmetic look like? 
}

\subsection{Addition}

\frame
{ 
	Does \mred{1 + 1 = 2}? How can we tell? 
}

\begin{frame}[fragile]
	By simple counting. Axiomatically, \red{1} is the type with \red{1} inhabitant, so
	\begin{minted}{haskell}
	
	1 + 1  
	= () + ()
	= Either () ()
	= 2
	\end{minted}
\end{frame}

\frame
{ 
	By inspection, we see that \red{Either} has precisely two cases - \blue{Left} and \blue{Right} containing a single type. Thus, two cases, with one inhabitant in each case. Therefore we have 2 inhabitants!
}

\frame
{ 
	How about \mred{Maybe} containing values of type \mblue{\bm{Bool} = \{ \top, \bot\}}? 
}

\begin{frame}[fragile]

Again, we can apply some natural deduction, nothing that \mblue{\bm{Bool}} has precisely two inhabitants
	\begin{minted}{haskell}
	
	Maybe Bool
	= Nothing + Just (True + False)
	= 1 + 1 + 1
	= 3
	\end{minted}
\end{frame}

\frame
{
	Simple right? Lets move on.
}

\subsection{Multiplication}

\frame
{

	Multiplication operates in the similar way. Using products, we can count \mred{\bm{Bool} * \bm{Bool}}. We have precisely four cases: 
	
	\begin{itemize}	
		\item \mblue{(True, True)}
		\item \mblue{(True, False)}
		\item \mblue{(False, True)}
		\item \mblue{(False, False)} 
	\end{itemize}
}

\frame
{
	This works out as well! How about exponents?
}

\subsection{Exponentiation}

\begin{frame}[fragile]
	Let's consider a function \mred{Bool \to Bool}. How do we count the number of functions we have? Well, we can list them out: 
	
	\begin{minted}{haskell}
		k1 :: Bool -> Bool
		k1 b 
		  | True = True
		  | False = False 
		
		k2 :: Bool -> Bool 
		k2 b 
		  | True = True
		  | False = True 
		  		
		-- and so on	
	\end{minted}
	
\end{frame}

\begin{frame}[fragile]

	tl;dr there are exactly 4 inabitants. Now, consider the functions
	
	\begin{minted}{haskell}
		f :: Maybe Bool -> Bool
		f ...
	\end{minted}
\end{frame}

\frame
{
	Upon inspection you might find that there are precisely 8 such functions. Inductively, we see that there are \mred{|b|^{|a|}}-many inhabitants to the type \mred{a \to b}. The cardinality of this type behaves like exponentiation in $\mathbb{N}$!
}

\subsection{$\top$ and $\bot$}

\frame
{
	Considering all we have just discussed, there are caveats to this calculus. For example, how many inhabitants are there in the type \mred{0 \to 1}? How about \mred{1 \to 0}? \mred{0 \to 0}?
}

\subsection{A correspondence Pt. 1}
\frame
{
	The analogy so far: 
	
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\hline
			Types & \# of Inhabitants  & Sets & Categories \\
			\hline a       & $|A|$ & ?  & ? \\
			(a, b) &  $|A| \times |B| $ & ? & ? \\
			Either a b & $|A| + |B|$ & ? & ? \\
			$a \to b$ & $|B|^{|A|}$ & ? & ? \\
			() & 1 & ? & ? \\
			Void & 0 & ? & ? \\ \hline
		\end{tabular}
	\end{center}

}

\frame
{ 
	\textbf{Claim}: we can fill in the rest of the table with direct analogies from Set theory and Category theory. 
}


\begin{frame}[fragile]
	What does this look like?
	
	\begin{center}
	\begin{minted}[escapeinside=||,mathescape]{haskell}
	
	leftUnitP  :: (|$1$| |$\times$| a) = a
	commuteP   :: (a |$\times$| b) = (b |$\times$| a)
	associateP :: ((a |$\times$| b) |$\times$| c) = (a |$\times$| (b |$\times$| c))
	leftUnitC  :: (|$0$| + a) = a
	commuteC   :: (a + b) = (b + a)
	associateC :: ((a + b) + c) = (a + (b + c))
	currying   :: |$c^{a \times b}$| = |$(c^b)^a$|
	leftUnitF  :: |$a^1$| = a
	rightUnitF :: |$1^a$| = |$1$|
	\end{minted}
	
	\end{center}
\end{frame}

\frame
{ 
	Why do we care in the first place? 
}

\frame
{ 
	Because proving that a type \mblue{T} has inhabitants is equivalent to proving the theorem correspondnig with \mblue{T} due to the Curry-Howard-Lambek correspondence.
}



\section{The Leibniz Perspective}

\subsection{When are things equal?}
\frame
{
	When are two things equal? You may have noticed our use of $=$ in the previous slides, but that was a convenient lie.
}

\frame
{
	Are these things equal? 
	
	\begin{itemize}
		\item \blue{1729}
		\item \mblue{12^3 + 1^3}
		\item "The first number expressible by the sum of two cubes in two different ways"
	\end{itemize}
}

\frame
{
	When viewed as expressions, \blue{1729} and \mblue{12^3 + 1^3} are different.
}

\frame
{
	When viewed as integers, they are the same. 
}

\subsection{Isomorphisms}
\frame
{
	Enumeration in this sense is an \red{isomorphism} from a type to a finite set. 
}


\begin{frame}[fragile]

	\begin{minted}{haskell}
	data Iso a b = Iso 
	    { to   :: a -> b
	    , from :: b -> a
	    }
	    -- fromTo :: (x :: a) -> (from . to) x = x
	    -- toFrom :: (x :: b) -> (to . from) x = x
	\end{minted}
\end{frame}

\frame
{
	We have been suffering from an abuse of notation - what we've really been saying is that two things are equal if we can exhibit an isomorphism between the two.
}

\frame
{ 
	\begin{prop}[Equality Preservation]
		if \red{A} and \blue{B} are isomorphic, and \mred{a_1, a_2 : A}, and \mblue{b_1, b_2 : B}, then \mred{a_1 = a_2} $\iff$ \mblue{b_1 = b_2}.
	\end{prop}
}

\subsection{Identity of Indiscernibles}
\frame
{

	\begin{prop}[Gottfried Wilhelm Leibniz, 1646-1716]
		"For any x and y, if x is identical to y, then x and y have all the same properties. For any x and y, if x and y have all the same properties, then x is identical to y."
	\end{prop}
	
}

\frame
{

	In symbols, \mblue{x = y \iff \forall P. Px = Py} where $P$ is quantified over all properties of $x$.
		
}

\subsection{Putting it to work}
\begin{frame}[fragile]
Let's see some interesting isomorphisms.

\begin{minted}{haskell}
leftUnitP :: Iso ((), a) a
leftUnitP = Iso (\((), a) -> a)
                (\a -> ((), a))
commuteP :: Iso (a, b) (b, a)
commuteP = Iso (\(a, b) -> (b, a))
               (\(b, a) -> (a, b))
associateP :: Iso ((a, b), c) (a, (b, c))
associateP = Iso (\((a, b), c) -> (a, (b, c)))
                 (\(a, (b, c)) -> ((a, b), c))
\end{minted}
\end{frame}
\begin{frame}[fragile]
What does this remind you of?
\begin{minted}{haskell}
rightUnitP  :: Iso (a, ()) a
leftUnitP   :: Iso ((), a) a
associateP  :: Iso ((a, b), c) (a, (b, c))
\end{minted}
\end{frame}
\begin{frame}[fragile]
\begin{minted}{haskell}
leftUnitC :: Iso (Either Void a) a
leftUnitC = ...
commuteC :: Iso (Either a b) (Either b a)
commuteC = ...
associateC :: Iso (Either (Either a b) c)
                  (Either a (Either b c))
associateC =
  Iso (\case Left (Left a)  -> Left a;
             Left (Right b) -> Right (Left b);
             Right c        -> Right (Right c))
      (\case Left a          -> Left (Left a);
             Right (Left b)  -> Left (Right b);
             Right (Right c) -> Right c)
\end{minted}
\end{frame}

\frame
{ 
	So what do our arithmetic rules \textit{really} say about our types?
}

\begin{frame}[fragile]
\begin{minted}[escapeinside=||,mathescape]{haskell}
leftUnitP  :: (|$1$| |$\times$| a) |$\cong$| a
commuteP   :: (a |$\times$| b) |$\cong$| (b |$\times$| a)
associateP :: ((a |$\times$| b) |$\times$| c) |$\cong$| (a |$\times$| (b |$\times$| c))
leftUnitC  :: (|$0$| + a) |$\cong$| a
commuteC   :: (a + b) |$\cong$| (b + a)
associateC :: ((a + b) + c) |$\cong$| (a + (b + c))
currying   :: |$c^{a \times b}$| |$\cong$| |$(c^b)^a$|
leftUnitF  :: |$a^1$| |$\cong$| a
rightUnitF :: |$1^a$| |$\cong$| |$1$|
\end{minted}
\end{frame}

\subsection{The million dollar question}

\frame
{ 
	By inspection, we can show that there is a correspondence between sets and types by looking at their cardinalities and inhabitants respectively. 
}

\frame
{
	What type has precisely \mred{(a * b)}-many inhabitants? What set? Likewise, what type has precisely \mred{(a + b)}-many inhabitants? What set?
}

\frame
{
	We continue to build the picture.
}

\begin{frame}
There is a correspondence between types, sets, natural numbers.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Types & Sets & \# of Inhabitants & Categories \\
\hline
a       & $A$ & $|A|$  & ? \\
(a, b) & $A \times B$ & $|A| \times |B|$ & ? \\
Either a b & $A \sqcup B$ & $|A| + |B|$ & ? \\
$a \to b$ &  set functions & $|B|^{|A|}$ & ? \\
() & $\{*\}$ & 1 & ? \\
Void & $\emptyset$ & 0 & ? \\ \hline
\end{tabular}
\end{center}
\end{frame}

\section{The Yoneda Perspective}


\subsection{Some Category Theory}

\frame
{
	\textbf{Claim}: the same correspondence can be made within the language of a bicartesian-closed category. 
}

\frame
{
	Lets elaborate on what that means. But first, some definitions.
}

\frame
{
	\begin{definition}[Category]
		A \textbf{category} $\cc$ consists of the following data: 
		
		\begin{itemize}
			\item a collection of \textbf{objects} \mred{x, y, z,...}
			\item a collection of \textbf{morphisms} \mred{f,g,h,...}
		\end{itemize}
		
		Such that 
		
		\begin{itemize}
			\item each morphism has specified \textbf{domain} and \textbf{codomain} objects so that the notation \mred{f : x \to y} signifies a morphism with domain \mred{x} and codomain \mred{y}. 
			\item each object has an associated \textbf{identity} morphism \mblue{1_x : x \to x} which acts as a two-sided unital element for composition.
			\item to each pair of morphisms \mred{f : x \to y}, \mblue{g : y \to z}, there exists a \textbf{composite} arrow $h : \red{x} \to \blue{z}$ where $h :\equiv \blue{g}\red{f}$. 
		\end{itemize}
	\end{definition}
}

\frame
{
	For every category we may speak of its dual notion, $\opc$, the \textbf{opposite} category of $\cc$, consisting of the same object data, but with the domain and codomain of each morphism reversed.
}

\frame
{
	This data is subject to some axioms. 
	
	\begin{itemize}
	
		\item For any $f : x \to y$, $f1_x = f =  1_y f$. 
		\item For any composable triple $f,g,h$, $h(gf) = (hg)f$, and will simply be denoted $hgf$.
		\item Between any two objects $x, y$ in a category $\cc$, there exists an object $\cc(x,y)$ consisting of all morphisms with domain $x$ and codomain $y$. This is usually called $Hom_{\cc}(x, y)$.
	\end{itemize}
}

\frame
{

	Indeed, we are familiar with morphisms, identities, and composition already. In haskell, these translate into types \mred{a \to b}, the* identity function \mred{id}, and composition \mred{(.)}. 
	
	In scala, these are roughly the same, modulo naming conventions - \mblue{A \Rightarrow B}, \mblue{identity}, \mblue{compose}.  
}

\frame
{ 
	Isomorphisms in this context become a pair of morphisms \mred{ f : c \to d} and \mblue{g : d \to c} such that $\blue{g}\red{f} = 1_c$ and $\red{f}\blue{g} = 1_y$.
	
	 If \mred{x} and \mblue{y} are isomorphic, we will denote this by $\red{x} \cong \blue{y}$.
}

\frame
{
	
	\begin{definition}[Functor]
		A functor $F : \cc \to \dd$ between categories consists of the following data: 
		
		\begin{itemize}
			\item an object $Fc$ in $\dd$ for every object c of $\cc$
			\item a morphism $Ff : Fc \to Fd$ in $\dd$ for each morphism $f : c \to d$ of $\cc$.
		\end{itemize}
		
		Additionally, we require that $Fg \cdot Ff = F(gf)$ when $g$ and $f$ are a composable pair, and that for every object $c$ in $\cc$, $F1_c = 1_{Fc}$.
	\end{definition}
}

\begin{frame}[fragile]
In Haskell, we represent this data as a typeclass

	\begin{minted}{haskell}
	class fmap :: (a -> b) -> f a -> f c
	-- fmap id fa = fa 
	-- fmap g . fmap f = fmap (g . f)
	\end{minted}
	
\end{frame}

\frame
{
	Functors that act uniformly on arrows are called \textbf{covariant}. However, if a functor is mapping to or from an opposite category to a normal category, then one calls these functors \textbf{contravariant}.
	
	 Operationally, this can be seen as "flipping the direction of arrows" in the target category. 
}

\frame
{
	This is often unnecessary data, as the saying a "$F$ is a contravariant functor from $\cc$ to $\dd$" is precisely saying one has a covariant functor $F : \opc \to \dd$. When it matters, I'll just tell you which one is opposite.

}

\subsection{Initial and Terminal Objects}

\frame
{
	"Special" objects are determined by how morphisms to or from them act in relation to other objects. 
}

\frame
{
	\begin{definition}{Terminal and Initial objects}
		An object $c$ of $\cc$ is called \textbf{terminal} if there is exactly 1 unique morphism from any other object in $\cc$ to $c$. 
		
		Dually,  an object $c$ of $\cc$ is \textbf{initial} if there is exactly 1 unique morphism to any other object in $\cc$. 
	\end{definition}
}

\frame
{
	We have seen two such objects that act like terminal and initial objects already: \mred{()} and \mblue{\bot}
}

\frame
{
	Indeed for every type $a$, the types \mred{a \to ()} and \mblue{\bot \to a} has precisely one inhabitant . 
}

\begin{frame}[fragile]

Namely, we have the following functions: 

	\begin{minted}[escapeinside=||,mathescape]{haskell}
	-- a -> ()
	k :: a -> ()
	k = const ()
	
	-- |$\bot$| -> a
	t :: Void -> a
	t = absurd
	\end{minted}
\end{frame}

\subsection{Products and Coproducts}

\frame
{

	In the same way that we have terminal and initial objects, constructions for products and coproducts in category theory follow suit.
}

\frame
{
	\begin{definition}[Product]
	
		A \textbf{product} in a category $\cc$ is an object $P$ together with morphisms $p_c : P \to c$ and $p_d : P \to d$ for $c,d$ in $\cc$ such that for any other object $N$ with morphisms $f_c : N \to c$ and $f_d : N \to d$, then each $f_{(-)}$ can be factored through a unique function $f : N \to P$ such that $f_c = p_cf$ and $f_d = p_df$. 
	\end{definition}
}

\begin{frame}[fragile]
	This is diagram gives this data succinctly: 
	
	\begin{center}
	\begin{tikzcd}
	& & c
	\\ N \ar[r, "f" description, dotted] \ar[urr, "f_c", bend left] \ar[drr, "f_d", bend right, swap] & P \ar[ur, "p_c"] \ar[dr, "p_d", swap]
	\\ & & d
	\end{tikzcd}
	\end{center}
\end{frame}

\begin{frame}[fragile]
	We are all familar with these: in Haskell and Scala, we have the type \mred{(a, b)}. Its defined by having two operators: 
	
	\begin{minted}{haskell}
	fst :: (a,b) -> a
	fst (a,_) = a
	
	snd :: (a,b) -> b
	snd (_,b) = b
	\end{minted}
\end{frame}

\frame
{ 
	\begin{definition}[Coroduct]
	
		A \textbf{coproduct} in a category $\cc$ is an object $P$ together with morphisms $i_c : c \to C $ and $i_d : C \to d$ for $c,d$ in $\cc$ such that for any other object $N$ with morphisms $f_c : c \to N$ and $f_d : d \to N$, then each $f_{(-)}$ can be factored through a unique function $f : C \to N$ such that $f_c = fi_c$ and $f_d = fi_d$. 
	\end{definition}
	
}

\begin{frame}[fragile]
	This is diagram gives this data succinctly: 
	
	\begin{center}
	\begin{tikzcd}
	c \ar[dr, "i_c", swap] \ar[drr, "f_c", bend left]
	\\ & C \ar[r, "f" description, dotted] & N
	\\ d \ar[ur, "i_d"] \ar[urr, "f_d", bend right, swap]
	\end{tikzcd}
	\end{center}
\end{frame}

\begin{frame}[fragile]
	We are all familar with these: in Haskell and Scala, we have the type \blue{Either} \blue{a} \blue{b}. Its defined by having two operators: 
	
	\begin{minted}{haskell}
	inl :: a -> Either a b
	inl = Left
	
	inr :: b -> Either a b
	inr = Right
	\end{minted}
\end{frame}

\
\section{Bringing it all back home}


\end{document}
